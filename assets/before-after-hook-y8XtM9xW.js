function s(r,e,u,n){if(typeof u!="function")throw new Error("method for before hook must be a function");return n||(n={}),Array.isArray(e)?e.reverse().reduce((i,t)=>s.bind(null,r,t,i,n),u)():Promise.resolve().then(()=>r.registry[e]?r.registry[e].reduce((i,t)=>t.hook.bind(null,i,n),u)():u(n))}function g(r,e,u,n){const i=n;r.registry[u]||(r.registry[u]=[]),e==="before"&&(n=(t,l)=>Promise.resolve().then(i.bind(null,l)).then(t.bind(null,l))),e==="after"&&(n=(t,l)=>{let o;return Promise.resolve().then(t.bind(null,l)).then(b=>(o=b,i(o,l))).then(()=>o)}),e==="error"&&(n=(t,l)=>Promise.resolve().then(t.bind(null,l)).catch(o=>i(o,l))),r.registry[u].push({hook:n,orig:i})}function y(r,e,u){if(!r.registry[e])return;const n=r.registry[e].map(i=>i.orig).indexOf(u);n!==-1&&r.registry[e].splice(n,1)}const f=Function.bind,c=f.bind(f);function d(r,e,u){const n=c(y,null).apply(null,[e]);r.api={remove:n},r.remove=n,["before","error","after","wrap"].forEach(i=>{const t=[e,i];r[i]=r.api[i]=c(g,null).apply(null,t)})}function v(){const r={registry:{}},e=s.bind(null,r);return d(e,r),e}const h={Collection:v};export{h as H};
